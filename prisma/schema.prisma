// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init
generator client {
  provider = "prisma-client-js"
}

/// Always after the prisma-client-js generator
generator json {
  provider = "prisma-json-types-generator"
  // namespace = "PrismaJson"
  // clientOutput = "<finds it automatically>"
  // (./ -> relative to schema, or an importable path to require() it)
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

// DND 5e data

// ALL ENUMS NEED A NULL VALUE FOR THE FRONT END TO WORK PROPERLY
enum Ability {
  STR
  CON
  DEX
  INT
  WIS
  CHA
}

enum ArmorType {
  LIGHT
  MEDIUM
  HEAVY
  SHIELDS
}

enum Size {
  TINY
  SMALL
  MEDIUM
  LARGE
  HUGE
  GARGANTUAN
  NULL
}

enum SpellSchool {
  ABJURATION
  CONJURATION
  DIVINATION
  ENCHANTMENT
  EVOCATION
  ILLUSION
  NECROMANCY
  TRANSMUTATION
  NULL
}

enum Currency {
  cp
  sp
  ep
  gp
  pp
}

enum Skill {
  ACROBATICS
  ANIMAL_HANDLING
  ARCANA
  ATHLETICS
  DECEPTION
  HISTORY
  INSIGHT
  INTIMIDATION
  INVESTIGATION
  MEDICINE
  NATURE
  PERCEPTION
  PERFORMANCE
  PERSUASION
  RELIGION
  SLEIGHT_OF_HAND
  STEALTH
  SURVIVAL
  NULL
}

enum Language {
  COMMON
  DWARVISH
  ELVISH
  GIANT
  GNOMISH
  GOBLIN
  HALFLING
  ORC
  ABYSSAL
  CELESTIAL
  DRACONIC
  DEEP_SPEECH
  INFERNAL
  PRIMORDIAL
  SYLVAN
  UNDERCOMMON
  NULL
}

enum DamageTypes {
  ACID
  BLUDGEONING
  COLD
  FIRE
  FORCE
  LIGHTNING
  NECROTIC
  PIERCING
  POISON
  PSYCHIC
  RADIANT
  SLASHING
  THUNDER
  NONE
  NULL
  OTHER
}

enum CreatureType {
  ABERRATION
  BEAST
  CELESTIAL
  CONSTRUCT
  DRAGON
  ELEMENTAL
  FEY
  FIEND
  GIANT
  HUMANOID
  MONSTROSITY
  OOZE
  PLANT
  UNDEAD
  NULL
}

model User {
  id          Int           @id @default(autoincrement())
  username    String        @unique
  email       String        @unique
  password    String
  Classes     Class[]
  SubClasses  SubClass[]
  Races       Race[]
  Background  Background[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  Spell       Spell[]
  Messages    Message[]
  RaceVariant RaceVariant[]

  Campaigns      Campaign[] @relation("PlayerCampaigns")
  GMForCampaigns Campaign[] @relation("GMCampaigns")
  Tool           Tool[]
  Item           Item[]
}

model Campaign {
  id           Int      @id @default(autoincrement())
  name         String
  description  String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  GameMaster   User     @relation("GMCampaigns", fields: [gameMasterId], references: [id])
  gameMasterId Int
  Players      User[]   @relation("PlayerCampaigns")
}

model Class {
  id  Int     @id @default(autoincrement())
  srd Boolean @default(false)

  name                     String
  description              String
  flavorText               String @db.VarChar(200)
  /// [AbilityScoreTrigger]
  multiclassing            Json
  multiclassingDescription String
  source                   String @default("Player's Handbook") //source of the class

  hitDie Int

  /// [AbilityChoice]
  savingThrows Json

  /// [SkillChoice]
  skills                 Json
  skillChoiceDescription String

  SubClasses            SubClass[]
  subClassName          String
  subClassDescription   String
  subClassFeatureLevels Int[]

  /// [Feature]
  features Json[]

  /// [ToolChoice]
  tools            Json
  toolsDescription String
  potentialTools   Tool[] @relation("ToolClass")

  /// [ArmorChoice]
  armor            Json
  armorDescription String

  /// [WeaponChoice]
  weapons           Json
  weaponDescription String
  potentialWeapons  Weapon[] @relation("WeaponClass")

  abilityScoreLevels Int[]

  /// [ItemChoice]
  equipment            Json //this is the starting items for the class
  equipmentDescription String[]
  potentialEquipment   Item[]   @relation("ItemClass")

  isSpellCaster    Boolean @default(false)
  /// [SpellCastingInfo]
  spellCastingInfo Json? //only exists if isSpellCaster is true

  SpellList            SpellList? @relation(fields: [spellListId], references: [id]) // If the class has a spell list, link it here
  spellListId          Int?
  spellListDescription String?

  //date fields
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  User   User? @relation(fields: [userId], references: [id])
  userId Int?
}

model Spell {
  id            Int          @id @default(autoincrement())
  srd           Boolean      @default(false)
  name          String
  description   String
  duration      String
  range         String
  castingTime   String
  verbal        Boolean      @default(false)
  somatic       Boolean      @default(false)
  material      Boolean      @default(false)
  materialCost  String?
  concentration Boolean      @default(false)
  ritual        Boolean      @default(false)
  upcastInfo    String?
  //search fields
  tags          String[]
  saveRequired  Boolean      @default(false)
  damageType    DamageTypes?
  aoe           Boolean      @default(false)
  conditions    String[]
  options       String[] // If the spell has options to choose from, list here  
  /// [Table]
  extendedTable Json[] // This table will be rendered with the spell
  postTableData String? // This is for any additional content that should be displayed after the table
  school        SpellSchool
  level         Int //0 is cantrip, 1-9 are spell levels
  source        String
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  User       User?       @relation(fields: [userId], references: [id])
  userId     Int?
  SpellLists SpellList[]
  Item       Item[]      @relation("SpellScroll")
}

model SpellList {
  id          Int    @id @default(autoincrement())
  name        String
  flavorText  String @db.VarChar(200)
  description String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Spells    Spell[]
  Classes   Class[]
}

model SubClass {
  id  Int     @id @default(autoincrement())
  srd Boolean @default(false)

  name        String
  description String
  flavorText  String @db.VarChar(200)
  source      String @default("Player's Handbook")

  /// [Feature]
  features Json[]

  isSpellCaster    Boolean @default(false)
  /// [SpellCastingInfo]
  spellCastingInfo Json? //only exists if isSpellCaster is true

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Class   Class? @relation(fields: [classId], references: [id])
  classId Int?
  User    User?  @relation(fields: [userId], references: [id])
  userId  Int?
}

model Race {
  id          Int     @id @default(autoincrement())
  srd         Boolean @default(false)
  name        String
  description String
  flavorText  String  @db.VarChar(200)
  source      String

  RacialTraits RacialTraits[]

  /// [AbilityScoreNumber]
  abilityScores           Json
  abilityScoreDescription String

  creatureType    CreatureType
  size            Size
  sizeDescription String?

  age       String
  alignment String

  skillProficiencies Skill[]

  /// [ToolChoice]
  toolProficiencies   Json?
  weaponProficiencies Int[] // Weapon IDs

  speed       Int
  flightSpeed Int?
  swimSpeed   Int?
  climbSpeed  Int?

  speedDescription  String
  flightDescription String?
  swimDescription   String?
  climbDescription  String?

  darkvision            Int?
  darkvisionDescription String?

  resistanceTo DamageTypes[]
  immuneTo     DamageTypes[]
  vulnerableTo DamageTypes[]

  /// [LanguageChoice]
  originLanguages     Json
  languageDescription String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Variants RaceVariant[]

  User   User? @relation(fields: [userId], references: [id])
  userId Int?
}

// This model has optional fields, whose purpose is to override the origin race its attached to
model RaceVariant {
  id                      Int     @id @default(autoincrement())
  srd                     Boolean @default(false)
  name                    String
  description             String
  flavorText              String  @db.VarChar(200)
  source                  String
  /// [AbilityScoreNumber]
  abilityScores           Json?
  abilityScoreDescription String?

  RacialTraits  RacialTraits[]
  removedTraits String[] // A list of traits that are removed from the base race. Case sensitive

  creatureType    CreatureType?
  size            Size?
  sizeDescription String?

  age       String?
  alignment String?

  skillProficiencies Skill[]

  /// [ToolChoice]
  toolProficiencies   Json?
  weaponProficiencies Int[] // Weapon IDs

  speed       Int?
  flightSpeed Int?
  swimSpeed   Int?
  climbSpeed  Int?

  speedDescription  String?
  flightDescription String?
  swimDescription   String?
  climbDescription  String?

  darkvision            Int?
  darkvisionDescription String?

  resistanceTo DamageTypes[]
  immuneTo     DamageTypes[]
  vulnerableTo DamageTypes[]

  /// [LanguageChoice]
  originLanguages     Json?
  languageDescription String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  User   User? @relation(fields: [userId], references: [id])
  userId Int?

  BaseRace   Race @relation(fields: [baseRaceId], references: [id])
  baseRaceId Int
}

model RacialTraits {
  id            Int          @id @default(autoincrement())
  name          String
  description   String
  /// [Table]
  extendedTable Json[]
  options       String[] // If the feature has options to choose from, list here
  postTableData String? // This is for any additional content that should be displayed after the table
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  Race          Race?        @relation(fields: [raceId], references: [id])
  raceId        Int?
  RaceVariant   RaceVariant? @relation(fields: [raceVariantId], references: [id])
  raceVariantId Int?
}

model Background {
  id                  Int                 @id @default(autoincrement())
  srd                 Boolean             @default(false)
  name                String
  description         String
  source              String              @default("Player's Handbook")
  flavorText          String              @db.VarChar(200)
  skillProficiencies  Skill[]
  skillChoiceCount    Int
  toolProficiencies   String[]
  languages           Language[]
  languageChoiceCount Int
  equipment           String[]
  Features            BackgroundFeature[]
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  User                User?               @relation(fields: [userId], references: [id])
  userId              Int?
}

model BackgroundFeature {
  id            Int      @id @default(autoincrement())
  name          String
  description   String
  /// [Table]
  extendedTable Json[]
  options       String[] // If the feature has options to choose from, list here

  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  Background   Background? @relation(fields: [backgroundId], references: [id])
  backgroundId Int?
}

model Feat {
  id          Int      @id @default(autoincrement())
  name        String
  description String
  source      String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Message {
  id        Int      @id @default(autoincrement())
  User      User?    @relation(fields: [userId], references: [id])
  userId    Int?
  email     String?
  message   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tool {
  id   Int    @id @default(autoincrement())
  name String

  /// [ToolSkill]
  skills Json[]

  components            String[] // Some tools have components that the character gets. These will be automatically added into the characters sheet
  componentsDescription String? // Description of the components

  /// [ToolFeature]
  features Json[]

  Items Item[]

  User   User? @relation(fields: [userId], references: [id])
  userId Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Class     Class[]  @relation("ToolClass")
}

enum ItemTypes {
  COMMON
  MAGIC
  CLOTHES
  ARCANE_FOCUS
  DRUIDIC_FOCUS
  HOLY_SYMBOL
  CONTAINER
  WEAPON
  ARMOR
  AMMUNITION
  COMPONENT_POUCH
  SPELL_BOOK
  EXPLOSIVE
  EQUIPMENT_PACK
  MISC
  TOOL
  CURRENCY
  SPELL_SCROLL
}

enum Unit {
  lb
  oz
  pint
  quart
  gal
}

model EquipmentPack {
  id   Int    @id @default(autoincrement())
  name String

  /// [QuantityItem]
  itemsQuantity Json[] //describes how many of each item is in the pack
  itemList      Item[] @relation("EquipmentPackParent")

  items Item[] @relation("EquipmentPackChild")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Item {
  id          Int    @id @default(autoincrement())
  name        String
  description String
  flavorText  String @db.VarChar(200)

  /// [CurrencyAmount]
  cost Json?

  /// [QuantityUnit]
  weight Json?

  /// [QuantityUnit]
  capacity Json?

  // unique item storage

  /// [QuantityItem]
  customItemCapacity Json?

  /// [Feature]
  features Json[]

  types ItemTypes[]

  // the item can be part of an equipment pack
  EquipmentPackList EquipmentPack[] @relation("EquipmentPackParent")
  //the item can be an equipment pack
  EquipmentPack     EquipmentPack?  @relation("EquipmentPackChild", fields: [equipmentPackId], references: [id])
  equipmentPackId   Int?

  // if the item is a tool we can link it to the tool model
  Tool   Tool? @relation(fields: [toolId], references: [id])
  toolId Int?

  User   User? @relation(fields: [userId], references: [id])
  userId Int?

  Spell   Spell? @relation("SpellScroll", fields: [spellId], references: [id])
  spellId Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Classes Class[] @relation("ItemClass")

  Weapon        Weapon?  @relation("ItemWeapon", fields: [weaponId], references: [id])
  weaponId      Int?
  AmmunitionFor Weapon[] @relation("WeaponAmmunition")
  Armor         Armor?   @relation("ItemArmor", fields: [armorId], references: [id])
  armorId       Int?
}

enum Rarity {
  COMMON
  UNCOMMON
  RARE
  VERY_RARE
  LEGENDARY
  ARTIFACT
}

model Weapon {
  id   Int    @id @default(autoincrement())
  name String

  // if the weapon is simple or martial
  isSimple Boolean

  /// [Damage]
  damage     Json[] // AND array (ex 1d6 piercing and 2d6 fire)
  /// [WeaponProperty]
  properties Json[] // AND array (ex finesse, light, thrown(20/60))
  Item       Item[] @relation("ItemWeapon")

  ammunition   Item?   @relation("WeaponAmmunition", fields: [ammunitionId], references: [id])
  ammunitionId Int?
  Class        Class[] @relation("WeaponClass")
}

model Armor {
  id   Int    @id @default(autoincrement())
  name String

  armorClass Int
  armorType  ArmorType

  /// [Feature]
  features Json[] // AND array (ex disadvantage on stealth checks)
  Item     Item[] @relation("ItemArmor")
}
